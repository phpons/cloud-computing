# Week 1 - Step 1

1. Make sure you can compile and run for both boards: VAP and VPB.
Same processor? Same amount of memory?
 
- Answer:
Both can be compile and run. VAP and VPB have different specifications, notably different CPUs and different amounts of memory (1M vs. 32M).
--------------------------------------------------------------------------------------------------------------------------------------------
2.1. Understand the linker script and the memory map relationship. Understand the BSS section and why it needs to be reset to 0.
Ans:
The linker script is defining the entry point of the code and positioning memory sections (such as the code, data, bss...). The bss section is reset to 0 because it is used for uninitialized data, therefore having leftover data in that memory section could be a problem.

2.2. Create global variables; some initalized and some uninitialized. Confirm you understand the relationship
between these global variables and the different data sections.
Ans:
Global data initialized to 0 or uninitialized will go to .bss (as it is guaranteed to be zeroed), the other variables are assigned to the .data section.

2.3. Experiment with "arm-none-eabi-objdump" to look at what the compiler does,
both on object files and on the file ELF executable.
Answer:
One thing to be observed here is that by running arm-none-eabi-objdump -D kernel.elf, we can see the sections are perfectly organized according to the linker script, which is kinda cool. Other than that, I did not extract much additional information.

2.4. Why is the bss section aligned on a 16-byte boundary? Confirm you see 
why in the code in the file "reset.s".
Answer:
It is done because 16B are zeroed at a time. ASM is writing to registers at a time, each register is of 4B size, therefore 16B.